using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Sharpility.Extensions;
using NodaTime;

namespace BungieNetApi._Platform.Models
{
    /// <summary>
    /// Sometimes, we have large sets of reusable plugs that are defined identically and thus can (and in some cases, are so large that they *must*) be shared across the places where they are used. These are the definitions for those reusable sets of plugs.    See DestinyItemSocketEntryDefinition.plugSource and reusablePlugSetHash for the relationship between these reusable plug sets and the sockets that leverage them (for starters, Emotes).   As of the release of Shadowkeep (Late 2019), these will begin to be sourced from game content directly - which means there will be many more of them, but it also means we may not get all data that we used to get for them.   DisplayProperties, in particular, will no longer be guaranteed to contain valid information. We will make a best effort to guess what ought to be populated there where possible, but it will be invalid for many/most plug sets.
    /// </summary>
    public sealed class DestinyDefinitionsSocketsDestinyPlugSetDefinition:  IEquatable<DestinyDefinitionsSocketsDestinyPlugSetDefinition>
    { 
        /// <summary>
        /// If you want to show these plugs in isolation, these are the display properties for them.
        /// </summary>
        public DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition DisplayProperties { get; private set; }

        /// <summary>
        /// This is a list of pre-determined plugs that can be plugged into this socket, without the character having the plug in their inventory.  If this list is populated, you will not be allowed to plug an arbitrary item in the socket: you will only be able to choose from one of these reusable plugs.
        /// </summary>
        public List<DestinyDefinitionsDestinyItemSocketEntryPlugItemRandomizedDefinition> ReusablePlugItems { get; private set; }

        /// <summary>
        /// Mostly for our debugging or reporting bugs, BNet is making \&quot;fake\&quot; plug sets in a desperate effort to reduce socket sizes.   If this is true, the plug set was generated by BNet: if it looks wrong, that&#39;s a good indicator that it&#39;s bungie.net that fucked this up.
        /// </summary>
        public bool? IsFakePlugSet { get; private set; }

        /// <summary>
        /// The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.
        /// </summary>
        public int? Hash { get; private set; }

        /// <summary>
        /// The index of the entity as it was found in the investment tables.
        /// </summary>
        public int? Index { get; private set; }

        /// <summary>
        /// If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!
        /// </summary>
        public bool? Redacted { get; private set; }


        /// <summary>
        /// Empty constructor required by some serializers.
        /// Use DestinyDefinitionsSocketsDestinyPlugSetDefinition.Builder() for instance creation instead.
        /// </summary>
        [Obsolete]
        public DestinyDefinitionsSocketsDestinyPlugSetDefinition()
        {
        }

        private DestinyDefinitionsSocketsDestinyPlugSetDefinition(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition DisplayProperties, List<DestinyDefinitionsDestinyItemSocketEntryPlugItemRandomizedDefinition> ReusablePlugItems, bool? IsFakePlugSet, int? Hash, int? Index, bool? Redacted)
        {
            
            this.DisplayProperties = DisplayProperties;
            
            this.ReusablePlugItems = ReusablePlugItems;
            
            this.IsFakePlugSet = IsFakePlugSet;
            
            this.Hash = Hash;
            
            this.Index = Index;
            
            this.Redacted = Redacted;
            
        }

        /// <summary>
        /// Returns builder of DestinyDefinitionsSocketsDestinyPlugSetDefinition.
        /// </summary>
        /// <returns>DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder</returns>
        public static DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder Builder()
        {
            return new DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder();
        }

        /// <summary>
        /// Returns DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder with properties set.
        /// Use it to change properties.
        /// </summary>
        /// <returns>DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder</returns>
        public DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder With()
        {
            return Builder()
                .DisplayProperties(DisplayProperties)
                .ReusablePlugItems(ReusablePlugItems)
                .IsFakePlugSet(IsFakePlugSet)
                .Hash(Hash)
                .Index(Index)
                .Redacted(Redacted);
        }

        public override string ToString()
        {
            return this.PropertiesToString();
        }

        public override bool Equals(object obj)
        {
            return this.EqualsByProperties(obj);
        }

        public bool Equals(DestinyDefinitionsSocketsDestinyPlugSetDefinition other)
        {
            return Equals((object) other);
        }

        public override int GetHashCode()
        {
            return this.PropertiesHash();
        }

        /// <summary>
        /// Implementation of == operator for (DestinyDefinitionsSocketsDestinyPlugSetDefinition.
        /// </summary>
        /// <param name="left">Compared (DestinyDefinitionsSocketsDestinyPlugSetDefinition</param>
        /// <param name="right">Compared (DestinyDefinitionsSocketsDestinyPlugSetDefinition</param>
        /// <returns>true if compared items are equals, false otherwise</returns>
        public static bool operator == (DestinyDefinitionsSocketsDestinyPlugSetDefinition left, DestinyDefinitionsSocketsDestinyPlugSetDefinition right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Implementation of != operator for (DestinyDefinitionsSocketsDestinyPlugSetDefinition.
        /// </summary>
        /// <param name="left">Compared (DestinyDefinitionsSocketsDestinyPlugSetDefinition</param>
        /// <param name="right">Compared (DestinyDefinitionsSocketsDestinyPlugSetDefinition</param>
        /// <returns>true if compared items are not equals, false otherwise</returns>
        public static bool operator != (DestinyDefinitionsSocketsDestinyPlugSetDefinition left, DestinyDefinitionsSocketsDestinyPlugSetDefinition right)
        {
            return !Equals(left, right);
        }

        /// <summary>
        /// Builder of DestinyDefinitionsSocketsDestinyPlugSetDefinition.
        /// </summary>
        public sealed class DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder
        {
            private DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition _DisplayProperties;
            private List<DestinyDefinitionsDestinyItemSocketEntryPlugItemRandomizedDefinition> _ReusablePlugItems;
            private bool? _IsFakePlugSet;
            private int? _Hash;
            private int? _Index;
            private bool? _Redacted;

            internal DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder()
            {
                SetupDefaults();
            }

            private void SetupDefaults()
            {
            }

            /// <summary>
            /// Sets value for DestinyDefinitionsSocketsDestinyPlugSetDefinition.DisplayProperties property.
            /// </summary>
            /// <param name="value">If you want to show these plugs in isolation, these are the display properties for them.</param>
            public DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder DisplayProperties(DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition value)
            {
                _DisplayProperties = value;
                return this;
            }

            /// <summary>
            /// Sets value for DestinyDefinitionsSocketsDestinyPlugSetDefinition.ReusablePlugItems property.
            /// </summary>
            /// <param name="value">This is a list of pre-determined plugs that can be plugged into this socket, without the character having the plug in their inventory.  If this list is populated, you will not be allowed to plug an arbitrary item in the socket: you will only be able to choose from one of these reusable plugs.</param>
            public DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder ReusablePlugItems(List<DestinyDefinitionsDestinyItemSocketEntryPlugItemRandomizedDefinition> value)
            {
                _ReusablePlugItems = value;
                return this;
            }

            /// <summary>
            /// Sets value for DestinyDefinitionsSocketsDestinyPlugSetDefinition.IsFakePlugSet property.
            /// </summary>
            /// <param name="value">Mostly for our debugging or reporting bugs, BNet is making \&quot;fake\&quot; plug sets in a desperate effort to reduce socket sizes.   If this is true, the plug set was generated by BNet: if it looks wrong, that&#39;s a good indicator that it&#39;s bungie.net that fucked this up.</param>
            public DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder IsFakePlugSet(bool? value)
            {
                _IsFakePlugSet = value;
                return this;
            }

            /// <summary>
            /// Sets value for DestinyDefinitionsSocketsDestinyPlugSetDefinition.Hash property.
            /// </summary>
            /// <param name="value">The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.  When entities refer to each other in Destiny content, it is this hash that they are referring to.</param>
            public DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder Hash(int? value)
            {
                _Hash = value;
                return this;
            }

            /// <summary>
            /// Sets value for DestinyDefinitionsSocketsDestinyPlugSetDefinition.Index property.
            /// </summary>
            /// <param name="value">The index of the entity as it was found in the investment tables.</param>
            public DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder Index(int? value)
            {
                _Index = value;
                return this;
            }

            /// <summary>
            /// Sets value for DestinyDefinitionsSocketsDestinyPlugSetDefinition.Redacted property.
            /// </summary>
            /// <param name="value">If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry!</param>
            public DestinyDefinitionsSocketsDestinyPlugSetDefinitionBuilder Redacted(bool? value)
            {
                _Redacted = value;
                return this;
            }


            /// <summary>
            /// Builds instance of DestinyDefinitionsSocketsDestinyPlugSetDefinition.
            /// </summary>
            /// <returns>DestinyDefinitionsSocketsDestinyPlugSetDefinition</returns>
            public DestinyDefinitionsSocketsDestinyPlugSetDefinition Build()
            {
                Validate();
                return new DestinyDefinitionsSocketsDestinyPlugSetDefinition(
                    DisplayProperties: _DisplayProperties,
                    ReusablePlugItems: _ReusablePlugItems,
                    IsFakePlugSet: _IsFakePlugSet,
                    Hash: _Hash,
                    Index: _Index,
                    Redacted: _Redacted
                );
            }

            private void Validate()
            { 
            }
        }

        
    }
}